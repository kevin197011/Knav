---
alwaysApply: true
---
# 🐹 Go 开发规范（工具开发 & Gin Web 全流程）

> 专注于 Go 语言现代开发最佳实践，涵盖工具/CLI、Gin Web、DevOps、自动化文档、测试、CI/CD、监控、前端对接等完整开发周期。

---

## 🎯 Go 开发原则

- 遵循 Go 官方代码规范和惯用法
- 使用 `gofmt`、`golint`、`go vet` 进行代码检查
- 采用清晰的包结构和命名规范
- 实施错误处理最佳实践
- 使用接口进行抽象和解耦

---

## 🏗 推荐项目结构

### Go 工具/CLI 项目
```
project/
├── cmd/                # 主命令入口
│   └── toolname/
│       └── main.go
├── internal/           # 内部实现包（不导出）
│   ├── logic/
│   ├── config/
│   └── utils/
├── pkg/                # 可复用包（可导出）
├── scripts/            # 构建/发布脚本
├── tests/              # 测试代码
├── go.mod
├── go.sum
├── Makefile
├── README.md
└── LICENSE
```

### Gin Web 项目
```
project/
├── cmd/
│   └── server/
│       └── main.go
├── internal/
│   ├── handler/        # 控制器
│   ├── service/        # 业务逻辑
│   ├── repository/     # 数据访问
│   ├── middleware/     # 中间件
│   ├── config/         # 配置
│   └── utils/          # 工具
├── pkg/                # 公共包
├── api/                # OpenAPI/Swagger
│   └── openapi.yaml
├── deployments/        # Docker/K8s
├── scripts/
├── tests/
├── go.mod
├── go.sum
├── Makefile
├── README.md
└── LICENSE
```

---

## 🚀 Gin Web 服务模板

### main.go
```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/example/project/internal/config"
    "github.com/example/project/internal/handler"
    "github.com/example/project/internal/middleware"
    "github.com/example/project/internal/repository"
    "github.com/example/project/internal/service"
    "github.com/example/project/pkg/logger"
)

func main() {
    cfg, err := config.Load()
    if err != nil {
        log.Fatalf("Failed to load config: %v", err)
    }
    logger := logger.New(cfg.LogLevel)
    db, err := repository.NewDB(cfg.DatabaseURL)
    if err != nil {
        logger.Fatal("Failed to connect to database", "error", err)
    }
    defer db.Close()
    userRepo := repository.NewUserRepository(db)
    userService := service.NewUserService(userRepo, logger)
    userHandler := handler.NewUserHandler(userService, logger)
    router := setupRouter(cfg, userHandler, logger)
    srv := &http.Server{
        Addr:         fmt.Sprintf(":%d", cfg.Port),
        Handler:      router,
        ReadTimeout:  time.Duration(cfg.ReadTimeout) * time.Second,
        WriteTimeout: time.Duration(cfg.WriteTimeout) * time.Second,
        IdleTimeout:  time.Duration(cfg.IdleTimeout) * time.Second,
    }
    go func() {
        logger.Info("Starting server", "port", cfg.Port)
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            logger.Fatal("Failed to start server", "error", err)
        }
    }()
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    logger.Info("Shutting down server...")
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    if err := srv.Shutdown(ctx); err != nil {
        logger.Fatal("Server forced to shutdown", "error", err)
    }
    logger.Info("Server exited")
}

func setupRouter(cfg *config.Config, userHandler *handler.UserHandler, logger logger.Logger) *gin.Engine {
    if cfg.Environment == "production" {
        gin.SetMode(gin.ReleaseMode)
    }
    router := gin.New()
    router.Use(middleware.Logger(logger))
    router.Use(middleware.Recovery(logger))
    router.Use(middleware.CORS())
    router.Use(middleware.RateLimiter())
    router.GET("/health", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "status":    "healthy",
            "timestamp": time.Now().UTC(),
        })
    })
    api := router.Group("/api/v1")
    {
        users := api.Group("/users")
        {
            users.POST("", userHandler.CreateUser)
            users.GET("", userHandler.ListUsers)
            users.GET(":id", userHandler.GetUser)
            users.PUT(":id", userHandler.UpdateUser)
            users.DELETE(":id", userHandler.DeleteUser)
        }
    }
    return router
}
```

---

## 🧩 业务分层接口示例

### model/user.go
```go
type User struct {
    ID        int64     `json:"id" db:"id"`
    Name      string    `json:"name" db:"name"`
    Email     string    `json:"email" db:"email"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
    UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}
```

### repository/user_repository.go
```go
type Repository interface {
    Create(ctx context.Context, user *User) error
    GetByID(ctx context.Context, id int64) (*User, error)
    GetByEmail(ctx context.Context, email string) (*User, error)
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id int64) error
    List(ctx context.Context, limit, offset int) ([]*User, error)
}
```

### service/user_service.go
```go
type Service interface {
    CreateUser(ctx context.Context, req *CreateUserRequest) (*User, error)
    GetUser(ctx context.Context, id int64) (*User, error)
    UpdateUser(ctx context.Context, id int64, req *CreateUserRequest) (*User, error)
    DeleteUser(ctx context.Context, id int64) error
    ListUsers(ctx context.Context, page, limit int) ([]*User, error)
}
```

---

## 🔧 工具类与日志

### pkg/logger/logger.go
```go
// 结构化日志接口与实现，支持 trace_id、分级、JSON 输出
// ...见上文详细代码...
```

### pkg/httpclient/client.go
```go
// 通用 HTTP 客户端，支持重试、日志、超时、JSON 解码
// ...见上文详细代码...
```

### internal/config/config.go
```go
// 环境变量优先的配置加载，支持多环境、校验、默认值
// ...见上文详细代码...
```

---

## 🧪 测试规范

- 单元测试用 Go 标准 testing 包 + testify/assert/mock
- 集成测试用 httptest + suite + 事务隔离
- 推荐结构：`internal/service/xxx_test.go`、`tests/integration/xxx_test.go`
- 见上文详细单元/集成测试代码

---

## 📚 自动化文档与 OpenAPI

### 1. 使用 swaggo 生成 Swagger/OpenAPI
- `go install github.com/swaggo/swag/cmd/swag@latest`
- `go get -u github.com/swaggo/gin-swagger`
- `go get -u github.com/swaggo/files`
- 在 main.go 和 handler 注释中添加 swagger 注解
- `swag init` 生成 docs
- 路由注册：
```go
import (
    ginSwagger "github.com/swaggo/gin-swagger"
    swaggerFiles "github.com/swaggo/files"
)
r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
```

### 2. 前端代码生成
- 推荐 openapi-generator 或 swagger-typescript-api
- 生成 TypeScript 客户端，前端直接调用
- 示例：
```sh
openapi-generator-cli generate -i http://localhost:8080/swagger/doc.json -g typescript-fetch -o frontend/src/api
# 或
swagger-typescript-api -p http://localhost:8080/swagger/doc.json -o frontend/src/api -n assetApi.ts
```

---

## 📈 监控与运维

- 推荐集成 Prometheus metrics（如 gin-prometheus、promhttp）
- 日志结构化输出，trace_id 贯穿全链路
- 健康检查 `/health` 路由
- Dockerfile、K8s YAML、CI/CD（GitHub Actions）全流程自动化

---

## 🖥️ 前端对接建议

- 前端（如 React+Tailwind）用 OpenAPI 生成的 TypeScript 客户端
- 典型 CRUD 页面结构：
  - 资产表格组件 AssetTable
  - 资产表单组件 AssetForm
  - 主页面 AssetsPage
- 见上文详细代码模板

---

## 🧪 CI/CD & DevOps

- 推荐 GitHub Actions 流水线，自动测试、构建、镜像推送、部署
- 关键步骤：
  - 代码检查（gofmt、golint、go vet）
  - 单元/集成测试
  - 构建二进制/镜像
  - 自动化部署

---

## 参考代码与最佳实践

- 见本规范各节代码块，或参考 [Go 官方文档](https://golang.org/doc/)、[Gin 官方文档](https://gin-gonic.com/)、[swaggo](https://github.com/swaggo/swag)、[openapi-generator](https://openapi-generator.tech/)

---

如需补充具体模块、脚手架、CI/CD、监控、前端对接等细节，请随时补充！

