---
alwaysApply: true
---
## ğŸ”§ Ruby å·¥å…·ç±»å’Œæ—¥å¿—è§„èŒƒ

### ç»Ÿä¸€æ—¥å¿—å·¥å…·ç±»
```ruby
# lib/utils/logger.rb
module Utils
  class Logger
    include Singleton

    def initialize
      @logger = ::Logger.new($stdout)
      @logger.level = log_level
      @logger.formatter = proc do |severity, datetime, progname, msg|
        {
          timestamp: datetime.iso8601,
          level: severity,
          service: service_name,
          message: msg,
          trace_id: current_trace_id
        }.to_json + "\n"
      end
    end

    def info(message, **context)
      log(:info, message, **context)
    end

    def error(message, error: nil, **context)
      context[:error] = error_details(error) if error
      log(:error, message, **context)
    end

    def warn(message, **context)
      log(:warn, message, **context)
    end

    def debug(message, **context)
      log(:debug, message, **context)
    end

    private

    def log(level, message, **context)
      log_data = { message: message }.merge(context)
      @logger.send(level, log_data.to_json)
    end

    def error_details(error)
      {
        class: error.class.name,
        message: error.message,
        backtrace: error.backtrace&.first(10)
      }
    end

    def log_level
      ENV.fetch('LOG_LEVEL', 'info').downcase.to_sym
    end

    def service_name
      ENV.fetch('SERVICE_NAME', 'ruby-service')
    end

    def current_trace_id
      Thread.current[:trace_id] || SecureRandom.hex(8)
    end
  end
end
```

### HTTP å®¢æˆ·ç«¯å·¥å…·ç±»
```ruby
# lib/utils/http_client.rb
module Utils
  class HttpClient
    include HTTParty

    base_uri ENV.fetch('API_BASE_URL', 'https://api.example.com')
    default_timeout 30

    def self.get_with_retry(path, options = {})
      retries = options.delete(:retries) || 3

      retries.times do |attempt|
        response = get(path, options)
        return parse_response(response) if response.success?

        sleep(2 ** attempt) if attempt < retries - 1
      end

      raise "Request failed after #{retries} attempts"
    end

    def self.post_with_auth(path, body, token)
      options = {
        body: body.to_json,
        headers: {
          'Content-Type' => 'application/json',
          'Authorization' => "Bearer #{token}"
        }
      }

      response = post(path, options)
      parse_response(response)
    end

    private

    def self.parse_response(response)
      case response.code
      when 200..299
        JSON.parse(response.body)
      when 400..499
        raise ClientError, "Client error: #{response.code} - #{response.body}"
      when 500..599
        raise ServerError, "Server error: #{response.code} - #{response.body}"
      else
        raise "Unexpected response: #{response.code}"
      end
    end
  end

  class ClientError < StandardError; end
  class ServerError < StandardError; end
end
```

### é…ç½®ç®¡ç†å·¥å…·ç±»
```ruby
# lib/utils/config.rb
module Utils
  class Config
    include Singleton

    def initialize
      @config = load_config
    end

    def get(key, default = nil)
      keys = key.to_s.split('.')
      value = keys.reduce(@config) { |hash, k| hash&.dig(k) }
      value || default
    end

    def database_url
      get('database.url') || ENV['DATABASE_URL']
    end

    def redis_url
      get('redis.url') || ENV['REDIS_URL']
    end

    def api_key
      get('api.key') || ENV['API_KEY']
    end

    def log_level
      get('log.level') || ENV['LOG_LEVEL'] || 'info'
    end

    private

    def load_config
      config_file = ENV['CONFIG_FILE'] || 'config/application.yml'

      if File.exist?(config_file)
        YAML.load_file(config_file)[environment] || {}
      else
        {}
      end
    end

    def environment
      ENV['RAILS_ENV'] || ENV['RACK_ENV'] || 'development'
    end
  end
end
```

---

## ğŸ§ª Ruby æµ‹è¯•è§„èŒƒ

### RSpec é…ç½®å’Œæœ€ä½³å®è·µ
```ruby
# spec/spec_helper.rb
RSpec.configure do |config|
  config.expect_with :rspec do |expectations|
    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
  end

  config.mock_with :rspec do |mocks|
    mocks.verify_partial_doubles = true
  end

  config.shared_context_metadata_behavior = :apply_to_host_groups
  config.filter_run_when_matching :focus
  config.example_status_persistence_file_path = "spec/examples.txt"
  config.disable_monkey_patching!
  config.warnings = true

  if config.files_to_run.one?
    config.default_formatter = "doc"
  end

  config.profile_examples = 10
  config.order = :random
  Kernel.srand config.seed
end
```

### å•å…ƒæµ‹è¯•ç¤ºä¾‹
```ruby
# spec/services/user_registration_service_spec.rb
RSpec.describe UserRegistrationService do
  describe '#call' do
    let(:user_params) { { name: 'John Doe', email: 'john@example.com' } }
    let(:service) { described_class.new(user_params: user_params) }

    context 'when valid parameters are provided' do
      it 'creates a new user' do
        expect { service.call }.to change(User, :count).by(1)
      end

      it 'returns true' do
        expect(service.call).to be true
      end

      it 'sends welcome email when requested' do
        service.send_welcome_email = true
        expect(UserMailer).to receive(:welcome_email).and_call_original
        service.call
      end
    end

    context 'when invalid parameters are provided' do
      let(:user_params) { { name: '', email: 'invalid-email' } }

      it 'does not create a user' do
        expect { service.call }.not_to change(User, :count)
      end

      it 'returns false' do
        expect(service.call).to be false
      end
    end
  end
end
```

### é›†æˆæµ‹è¯•ç¤ºä¾‹
```ruby
# spec/requests/api/v1/users_spec.rb
RSpec.describe 'API V1 Users', type: :request do
  let(:user) { create(:user) }
  let(:headers) { { 'Authorization' => "Bearer #{user.api_token}" } }

  describe 'GET /api/v1/users' do
    it 'returns list of users' do
      create_list(:user, 3)

      get '/api/v1/users', headers: headers

      expect(response).to have_http_status(:ok)
      expect(JSON.parse(response.body)).to have_key('users')
    end
  end

  describe 'POST /api/v1/users' do
    let(:user_params) do
      {
        user: {
          name: 'New User',
          email: 'newuser@example.com',
          password: 'password123'
        }
      }
    end

    it 'creates a new user' do
      post '/api/v1/users', params: user_params, headers: headers

      expect(response).to have_http_status(:created)
      expect(User.last.name).to eq('New User')
    end
  end
end
```
      expect(User.last.name).to eq('New User')
    end
  end
end
```

---

## ğŸ› ï¸ å¯ç»´æŠ¤ã€å¯æµ‹è¯•çš„ç”Ÿäº§çº§ Ruby ä»£ç 

é«˜è´¨é‡çš„ Ruby ä»£ç ä¸ä»…è¦â€œèƒ½è·‘â€ï¼Œæ›´è¦é•¿æœŸå¯ç»´æŠ¤ã€æ˜“æµ‹è¯•ã€æ˜“æ‰©å±•ã€‚ä»¥ä¸‹ä¸ºç”Ÿäº§çº§ Ruby ä»£ç çš„æ ¸å¿ƒæ ‡å‡†ä¸å®è·µå»ºè®®ï¼š

### 1. å¯ç»´æŠ¤æ€§æ ‡å‡†
- ç»“æ„æ¸…æ™°ã€æ¨¡å—åŒ–ï¼Œå•ä¸€èŒè´£ï¼ˆSRPï¼‰
- å‘½åè§„èŒƒã€å«ä¹‰æ˜ç¡®ï¼Œé¿å…ç¼©å†™å’Œæ— æ„ä¹‰å‘½å
- ä»£ç é£æ ¼ç»Ÿä¸€ï¼ˆå»ºè®® RuboCop æ£€æŸ¥ï¼‰ï¼Œç¼©è¿›ã€ç©ºæ ¼ã€æ³¨é‡Šæ°å½“
- é”™è¯¯å¤„ç†å¥å£®ï¼Œå¼‚å¸¸æœ‰æ•è·ã€æ—¥å¿—æœ‰è¾“å‡ºï¼Œç»Ÿä¸€å¤„ç†æœºåˆ¶
- å…³é”®æ¨¡å—/å‡½æ•°æœ‰æ–‡æ¡£æ³¨é‡Šï¼Œå¤æ‚é€»è¾‘æœ‰è¯´æ˜

### 2. å¯æµ‹è¯•æ€§æ ‡å‡†
- é€»è¾‘å¯æ‹†è§£ã€å¯éš”ç¦»ï¼Œå‡½æ•°/æ–¹æ³•å°½é‡æ— å‰¯ä½œç”¨
- ä¾èµ–æ³¨å…¥ï¼ˆå¦‚ loggerã€å¤–éƒ¨æœåŠ¡ï¼‰ä¾¿äº mock/stub
- å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€E2E æµ‹è¯•é½å…¨ï¼ŒCI è‡ªåŠ¨åŒ–
- å…³é”®è·¯å¾„æœ‰æ—¥å¿—/metrics/tracingï¼Œä¾¿äºè§‚æµ‹

### 3. ç”Ÿäº§çº§ä»£ç  checklist

| ç»´åº¦   | æ£€æŸ¥é¡¹                         |
| ---- | --------------------------- |
| ç»“æ„   | æ¯ä¸ªç±»/æ¨¡å—æ˜¯å¦èŒè´£å•ä¸€ï¼Ÿ               |
| å‘½å   | æ‰€æœ‰å‘½åæ˜¯å¦æ¸…æ™°æ˜ç¡®ï¼Ÿ                 |
| é”™è¯¯å¤„ç† | æ‰€æœ‰å¼‚å¸¸æ˜¯å¦è¢«æ•è·å¤„ç†ï¼Ÿæ˜¯å¦è®°å½•äº†æ—¥å¿—ï¼Ÿ        |
| å¯æµ‹è¯•  | æ‰€æœ‰é€»è¾‘æ˜¯å¦å¯ä»¥è¢« mock/stubï¼Ÿæ˜¯å¦èƒ½å†™æµ‹è¯•ï¼Ÿ |
| æ¥å£   | æ˜¯å¦æœ‰æ˜ç¡®çš„ API åˆçº¦ï¼ˆå…¥å‚å‡ºå‚ã€çŠ¶æ€ç ï¼‰ï¼Ÿ    |
| å¯è¯»æ€§  | æ˜¯å¦æ˜“æ‡‚ï¼Ÿæ˜¯å¦éœ€è¦é¢å¤–è¯´æ˜æ‰èƒ½ç†è§£ï¼Ÿ          |
| è‡ªåŠ¨åŒ–  | æ˜¯å¦æœ‰æµ‹è¯•ï¼ŸCI æ˜¯å¦èƒ½éªŒè¯ï¼Ÿ             |

### 4. Ruby ä»£ç ç¤ºä¾‹å¯¹æ¯”

#### âŒ ä¸å¯ç»´æŠ¤ / ä¸å¯æµ‹è¯•
```ruby
def do_something(data)
  result = []
  data.each do |x|
    if x[:type] == "a"
      # ...
    else
      # ...
    end
  end
  File.open("/tmp/log.txt", "a") { |f| f.write(result.to_s) }
end
```

#### âœ… å¯ç»´æŠ¤ / å¯æµ‹è¯•
```ruby
class DataProcessor
  def initialize(logger: Logger.new($stdout))
    @logger = logger
  end

  def process(data)
    result = data.map { |item| handle_item(item) }
    log_result(result)
    result
  end

  private

  def handle_item(item)
    case item[:type]
    when "a" then process_type_a(item)
    when "b" then process_type_b(item)
    else
      raise "Unknown type: #{item[:type]}"
    end
  end

  def process_type_a(item)
    # ...
  end

  def process_type_b(item)
    # ...
  end

  def log_result(result)
    @logger.info("Process result: #{result}")
  end
end
```

### 5. å·¥å…·æ¨è
- **ä»£ç è§„èŒƒæ£€æŸ¥**ï¼š`rubocop`
- **æµ‹è¯•æ¡†æ¶**ï¼š`rspec`, `minitest`
- **Mock å·¥å…·**ï¼š`rspec-mocks`, `mocha`
- **CI å·¥å…·**ï¼šGitHub Actions, Travis CI, CircleCI

### 6. DevOps/åç«¯åœºæ™¯è¡¥å……å»ºè®®
- é…ç½®å¯æ³¨å…¥ï¼ˆENVã€YAMLã€CLI argsï¼‰
- å…³é”®è·¯å¾„æœ‰æ—¥å¿—ã€Prometheus metricsã€trace
- å¤±è´¥å¯æ¢å¤ï¼ˆè¶…æ—¶ã€é‡è¯•ã€ç†”æ–­ç­‰ï¼‰

---
      expect(User.last.name).to eq('New User')
    end
  end
end
```
      expect(User.last.name).to eq('New User')
    end
  end
end
```