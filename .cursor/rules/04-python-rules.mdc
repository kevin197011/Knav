---
alwaysApply: true
---
## ğŸš€ FastAPI å¼€å‘è§„èŒƒ

### API ç»“æ„å’Œæœ€ä½³å®è·µ
```python
# main.py
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from contextlib import asynccontextmanager
import uvicorn

from .routers import users, auth
from .database import engine, create_tables
from .middleware import LoggingMiddleware

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    await create_tables()
    yield
    # Shutdown
    await engine.dispose()

app = FastAPI(
    title="My API",
    description="A sample API with best practices",
    version="1.0.0",
    lifespan=lifespan
)

# Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
app.add_middleware(GZipMiddleware, minimum_size=1000)
app.add_middleware(LoggingMiddleware)

# Routers
app.include_router(auth.router, prefix="/auth", tags=["auth"])
app.include_router(users.router, prefix="/users", tags=["users"])

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### è·¯ç”±å’Œä¾èµ–æ³¨å…¥
```python
# routers/users.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List

from ..database import get_db_session
from ..models import User
from ..schemas import UserCreate, UserResponse
from ..services import UserService
from ..auth import get_current_user

router = APIRouter()

@router.post("/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(
    user_data: UserCreate,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(get_current_user)
):
    """åˆ›å»ºæ–°ç”¨æˆ·"""
    try:
        user_service = UserService(db)
        user = await user_service.create_user(user_data.dict())
        return UserResponse.from_orm(user)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )

@router.get("/", response_model=List[UserResponse])
async def list_users(
    skip: int = 0,
    limit: int = 100,
    db: AsyncSession = Depends(get_db_session)
):
    """è·å–ç”¨æˆ·åˆ—è¡¨"""
    user_service = UserService(db)
    users = await user_service.get_users(skip=skip, limit=limit)
    return [UserResponse.from_orm(user) for user in users]

@router.get("/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: int,
    db: AsyncSession = Depends(get_db_session)
):
    """è·å–å•ä¸ªç”¨æˆ·"""
    user_service = UserService(db)
    user = await user_service.get_user_by_id(user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    return UserResponse.from_orm(user)
```

---

## ğŸ”§ Python å·¥å…·ç±»å’Œæ—¥å¿—è§„èŒƒ

### ç»Ÿä¸€æ—¥å¿—å·¥å…·ç±»
```python
# utils/logger.py
import logging
import json
import sys
from datetime import datetime
from typing import Any, Dict, Optional
from contextvars import ContextVar
import uuid

# Context variables for tracing
trace_id_var: ContextVar[str] = ContextVar('trace_id', default='')

class StructuredLogger:
    def __init__(self, name: str, level: str = "INFO"):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(getattr(logging, level.upper()))

        if not self.logger.handlers:
            handler = logging.StreamHandler(sys.stdout)
            handler.setFormatter(self._get_formatter())
            self.logger.addHandler(handler)

    def _get_formatter(self):
        return logging.Formatter(
            fmt='%(message)s',
            datefmt='%Y-%m-%dT%H:%M:%S'
        )

    def _format_log(self, level: str, message: str, **kwargs) -> str:
        log_data = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "level": level,
            "service": "python-service",
            "message": message,
            "trace_id": trace_id_var.get() or str(uuid.uuid4())[:8],
            **kwargs
        }
        return json.dumps(log_data, default=str)

    def info(self, message: str, **kwargs):
        self.logger.info(self._format_log("INFO", message, **kwargs))

    def error(self, message: str, error: Optional[Exception] = None, **kwargs):
        if error:
            kwargs["error"] = {
                "type": error.__class__.__name__,
                "message": str(error),
                "traceback": str(error.__traceback__)
            }
        self.logger.error(self._format_log("ERROR", message, **kwargs))

    def warning(self, message: str, **kwargs):
        self.logger.warning(self._format_log("WARNING", message, **kwargs))

    def debug(self, message: str, **kwargs):
        self.logger.debug(self._format_log("DEBUG", message, **kwargs))

# Global logger instance
logger = StructuredLogger(__name__)
```

### HTTP å®¢æˆ·ç«¯å·¥å…·ç±»
```python
# utils/http_client.py
import aiohttp
import asyncio
from typing import Dict, Any, Optional
from dataclasses import dataclass
import json

@dataclass
class HttpResponse:
    status: int
    data: Any
    headers: Dict[str, str]

class HttpClient:
    def __init__(self, base_url: str = "", timeout: int = 30):
        self.base_url = base_url.rstrip('/')
        self.timeout = aiohttp.ClientTimeout(total=timeout)
        self.session: Optional[aiohttp.ClientSession] = None

    async def __aenter__(self):
        self.session = aiohttp.ClientSession(timeout=self.timeout)
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    async def _request(
        self,
        method: str,
        path: str,
        data: Optional[Dict] = None,
        headers: Optional[Dict] = None,
        **kwargs
    ) -> HttpResponse:
        url = f"{self.base_url}{path}" if self.base_url else path

        if not self.session:
            raise RuntimeError("HttpClient must be used as async context manager")

        async with self.session.request(
            method,
            url,
            json=data,
            headers=headers,
            **kwargs
        ) as response:
            try:
                response_data = await response.json()
            except json.JSONDecodeError:
                response_data = await response.text()

            return HttpResponse(
                status=response.status,
                data=response_data,
                headers=dict(response.headers)
            )

    async def get(self, path: str, **kwargs) -> HttpResponse:
        return await self._request("GET", path, **kwargs)

    async def post(self, path: str, data: Dict = None, **kwargs) -> HttpResponse:
        return await self._request("POST", path, data=data, **kwargs)
```

---

## ğŸ§ª Python æµ‹è¯•è§„èŒƒ

### pytest é…ç½®
```python
# conftest.py
import pytest
import asyncio
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from httpx import AsyncClient

from src.main import app
from src.database import get_db_session, Base
from src.models import User

# Test database URL
TEST_DATABASE_URL = "postgresql+asyncpg://test:test@localhost/test_db"

@pytest.fixture(scope="session")
def event_loop():
    """Create an instance of the default event loop for the test session."""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture(scope="session")
async def test_engine():
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    yield engine
    await engine.dispose()

@pytest.fixture
async def test_session(test_engine):
    async_session = sessionmaker(
        test_engine, class_=AsyncSession, expire_on_commit=False
    )
    async with async_session() as session:
        yield session
        await session.rollback()

@pytest.fixture
async def client(test_session):
    def override_get_db():
        yield test_session

    app.dependency_overrides[get_db_session] = override_get_db

    async with AsyncClient(app=app, base_url="http://test") as client:
        yield client

    app.dependency_overrides.clear()

@pytest.fixture
async def test_user(test_session):
    user = User(
        name="Test User",
        email="test@example.com",
        hashed_password="hashed_password"
    )
    test_session.add(user)
    await test_session.commit()
    await test_session.refresh(user)
    return user
```

### å•å…ƒæµ‹è¯•ç¤ºä¾‹
```python
# tests/test_user_service.py
import pytest
from src.services.user_service import UserService
from src.models import User

@pytest.mark.asyncio
async def test_create_user(test_session):
    service = UserService(test_session)
    user_data = {
        "name": "John Doe",
        "email": "john@example.com",
        "password": "password123"
    }

    user = await service.create_user(user_data)

    assert user.name == "John Doe"
    assert user.email == "john@example.com"
    assert user.id is not None

@pytest.mark.asyncio
async def test_get_user_by_email(test_session, test_user):
    service = UserService(test_session)

    user = await service.get_user_by_email("test@example.com")

    assert user is not None
    assert user.email == "test@example.com"

@pytest.mark.asyncio
async def test_get_user_by_email_not_found(test_session):
    service = UserService(test_session)

    user = await service.get_user_by_email("nonexistent@example.com")

    assert user is None
```

---

## ğŸ› ï¸ å¯ç»´æŠ¤ã€å¯æµ‹è¯•çš„ç”Ÿäº§çº§ Python ä»£ç 

é«˜è´¨é‡çš„ Python ä»£ç ä¸ä»…è¦â€œèƒ½è·‘â€ï¼Œæ›´è¦é•¿æœŸå¯ç»´æŠ¤ã€æ˜“æµ‹è¯•ã€æ˜“æ‰©å±•ã€‚ä»¥ä¸‹ä¸ºç”Ÿäº§çº§ Python ä»£ç çš„æ ¸å¿ƒæ ‡å‡†ä¸å®è·µå»ºè®®ï¼š

### 1. å¯ç»´æŠ¤æ€§æ ‡å‡†
- ç»“æ„æ¸…æ™°ã€æ¨¡å—åŒ–ï¼Œå•ä¸€èŒè´£ï¼ˆSRPï¼‰
- å‘½åè§„èŒƒã€å«ä¹‰æ˜ç¡®ï¼Œé¿å…ç¼©å†™å’Œæ— æ„ä¹‰å‘½å
- ä»£ç é£æ ¼ç»Ÿä¸€ï¼ˆå»ºè®® PEP8 + Black/flake8 æ£€æŸ¥ï¼‰ï¼Œç¼©è¿›ã€ç©ºæ ¼ã€æ³¨é‡Šæ°å½“
- é”™è¯¯å¤„ç†å¥å£®ï¼Œå¼‚å¸¸æœ‰æ•è·ã€æ—¥å¿—æœ‰è¾“å‡ºï¼Œç»Ÿä¸€å¤„ç†æœºåˆ¶
- å…³é”®æ¨¡å—/å‡½æ•°æœ‰ docstringï¼Œå¤æ‚é€»è¾‘æœ‰è¯´æ˜

### 2. å¯æµ‹è¯•æ€§æ ‡å‡†
- é€»è¾‘å¯æ‹†è§£ã€å¯éš”ç¦»ï¼Œå‡½æ•°/æ–¹æ³•å°½é‡æ— å‰¯ä½œç”¨
- ä¾èµ–æ³¨å…¥ï¼ˆå¦‚ loggerã€å¤–éƒ¨æœåŠ¡ï¼‰ä¾¿äº mock/stub
- å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€E2E æµ‹è¯•é½å…¨ï¼ŒCI è‡ªåŠ¨åŒ–
- å…³é”®è·¯å¾„æœ‰æ—¥å¿—/metrics/tracingï¼Œä¾¿äºè§‚æµ‹

### 3. ç”Ÿäº§çº§ä»£ç  checklist

| ç»´åº¦   | æ£€æŸ¥é¡¹                         |
| ---- | --------------------------- |
| ç»“æ„   | æ¯ä¸ªç±»/æ¨¡å—æ˜¯å¦èŒè´£å•ä¸€ï¼Ÿ               |
| å‘½å   | æ‰€æœ‰å‘½åæ˜¯å¦æ¸…æ™°æ˜ç¡®ï¼Ÿ                 |
| é”™è¯¯å¤„ç† | æ‰€æœ‰å¼‚å¸¸æ˜¯å¦è¢«æ•è·å¤„ç†ï¼Ÿæ˜¯å¦è®°å½•äº†æ—¥å¿—ï¼Ÿ        |
| å¯æµ‹è¯•  | æ‰€æœ‰é€»è¾‘æ˜¯å¦å¯ä»¥è¢« mock/stubï¼Ÿæ˜¯å¦èƒ½å†™æµ‹è¯•ï¼Ÿ |
| æ¥å£   | æ˜¯å¦æœ‰æ˜ç¡®çš„ API åˆçº¦ï¼ˆå…¥å‚å‡ºå‚ã€çŠ¶æ€ç ï¼‰ï¼Ÿ    |
| å¯è¯»æ€§  | æ˜¯å¦æ˜“æ‡‚ï¼Ÿæ˜¯å¦éœ€è¦é¢å¤–è¯´æ˜æ‰èƒ½ç†è§£ï¼Ÿ          |
| è‡ªåŠ¨åŒ–  | æ˜¯å¦æœ‰æµ‹è¯•ï¼ŸCI æ˜¯å¦èƒ½éªŒè¯ï¼Ÿ             |

### 4. Python ä»£ç ç¤ºä¾‹å¯¹æ¯”

#### âŒ ä¸å¯ç»´æŠ¤ / ä¸å¯æµ‹è¯•
```python
def do_something(data):
    result = []
    for x in data:
        if x["type"] == "a":
            # ...
            pass
        else:
            # ...
            pass
    with open("/tmp/log.txt", "a") as f:
        f.write(str(result))
```

#### âœ… å¯ç»´æŠ¤ / å¯æµ‹è¯•
```python
import logging
from typing import List, Dict, Any

logger = logging.getLogger(__name__)

class DataProcessor:
    def __init__(self, logger=logger):
        self.logger = logger

    def process(self, data: List[Dict[str, Any]]) -> List[Any]:
        result = [self.handle_item(item) for item in data]
        self.log_result(result)
        return result

    def handle_item(self, item: Dict[str, Any]) -> Any:
        if item["type"] == "a":
            return self.process_type_a(item)
        elif item["type"] == "b":
            return self.process_type_b(item)
        else:
            raise ValueError(f"Unknown type: {item['type']}")

    def process_type_a(self, item):
        # ...
        pass

    def process_type_b(self, item):
        # ...
        pass

    def log_result(self, result):
        self.logger.info(f"Process result: {result}")
```

### 5. å·¥å…·æ¨è
- **ä»£ç è§„èŒƒæ£€æŸ¥**ï¼š`black`, `flake8`, `isort`, `mypy`
- **æµ‹è¯•æ¡†æ¶**ï¼š`pytest`, `unittest`
- **Mock å·¥å…·**ï¼š`unittest.mock`, `pytest-mock`
- **CI å·¥å…·**ï¼šGitHub Actions, Travis CI, CircleCI

### 6. DevOps/åç«¯åœºæ™¯è¡¥å……å»ºè®®
- é…ç½®å¯æ³¨å…¥ï¼ˆENVã€YAMLã€CLI argsï¼‰
- å…³é”®è·¯å¾„æœ‰æ—¥å¿—ã€Prometheus metricsã€trace
- å¤±è´¥å¯æ¢å¤ï¼ˆè¶…æ—¶ã€é‡è¯•ã€ç†”æ–­ç­‰ï¼‰

### 9. æœ€å°å¯è§æ€§åŸåˆ™ï¼ˆPrinciple of Least Visibilityï¼‰
- é™¤éå¿…è¦ï¼Œä¸è¦æš´éœ²ä»»ä½•æ¥å£ã€æ–¹æ³•æˆ–å˜é‡ã€‚
- Python è™½æ— å¼ºåˆ¶è®¿é—®æ§åˆ¶ï¼Œä½†åº”éµå¾ªä¸‹åˆ’çº¿å‘½åçº¦å®šï¼ˆå¦‚ `_method()` è¡¨ç¤ºç§æœ‰ï¼‰ï¼Œä»…å…¬å¼€æ˜ç¡®éœ€è¦è¢«å¤–éƒ¨è°ƒç”¨çš„éƒ¨åˆ†ã€‚
- è¯¥åŸåˆ™ä½“ç°ä¿¡æ¯éšè—å’Œå°è£…æ€æƒ³ï¼Œæœ‰åŠ©äºé™ä½è€¦åˆã€æå‡å¯ç»´æŠ¤æ€§ã€é˜²æ­¢è¯¯ç”¨ã€‚
- ç›¸å…³åŸåˆ™ï¼šæœ€å°æƒé™åŸåˆ™ã€å•ä¸€èŒè´£åŸåˆ™ã€å°è£…ã€‚


    user = await service.get_user_by_email("nonexistent@example.com")

    assert user is None
```